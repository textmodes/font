// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"

	"textmod.es/font/rom"
)

type Maps []*rom.Map

func (m Maps) Len() int           { return len(m) }
func (m Maps) Less(i, j int) bool { return m[i].Name < m[j].Name }
func (m Maps) Swap(i, j int)      { m[i], m[j] = m[j], m[i] }

func main() {
	d, err := os.Open("./rom")
	if err != nil {
		log.Fatalln(err)
	}

	files, err := d.Readdirnames(-1)
	if err != nil {
		log.Fatalln(err)
	}

	var maps Maps
	for _, file := range files {
		for _, collection := range rom.ROMs {
			if collection.Match(file) {
				m, err := collection.Parse(filepath.Join(d.Name(), file+".map"))
				if err != nil {
					log.Fatalf("%s: %v\n", file, err)
				}
				log.Println("parsed", m)
				maps = append(maps, m)
			}
		}
	}
	sort.Sort(maps)

	w := new(bytes.Buffer)
	w.WriteString(preamble)

	fmt.Fprintln(w, "var (")
	for _, m := range maps {
		fmt.Fprintf(w, "  %s = &Bitmap{\n", m.ExportName())
		fmt.Fprintf(w, "    Data:        %s,\n", m.InternalName())
		fmt.Fprintf(w, "    Size:        image.Point{%d, %d},\n", m.Size.X, m.Size.Y)
		fmt.Fprintf(w, "    Advance:     %d,\n", m.Size.X+int(m.Advance))
		fmt.Fprintf(w, "    Alpha:       color.Alpha{0xff},\n")
		fmt.Fprintf(w, "    CodePoint:   %sCodePoint,\n", m.InternalName())
		fmt.Fprintf(w, "    Encoding:    \"%s\",\n", m.Encoding)
		fmt.Fprintf(w, "    Replacement: %q,\n", m.Replacement)
		fmt.Fprintf(w, "  }\n")
	}
	fmt.Fprintln(w, ")")
	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "var (")
	for _, m := range maps {
		fmt.Fprintf(w, "  %s = []uint16{\n", m.InternalName())
		for x := 0; x < len(m.Data); x += 8 {
			fmt.Fprint(w, "     ")
			for _, b := range m.Data[x : x+8] {
				fmt.Fprintf(w, "%#02x,", b)
			}
			fmt.Fprint(w, "\n")
		}
		fmt.Fprintf(w, "  }\n")
		fmt.Fprintf(w, "  %sCodePoint = []rune{\n", m.InternalName())
		for x := 0; x < len(m.CodePoints); x += 8 {
			for _, c := range m.CodePoints[x : x+8] {
				fmt.Fprintf(w, "%#04x,", c)
			}
			fmt.Fprint(w, "\n")
		}
		fmt.Fprintf(w, "  }\n\n")
	}
	fmt.Fprintln(w, ")")

	s := w.Bytes()
	if s, err = format.Source(s); err != nil {
		log.Fatalln(err)
	}

	if err = ioutil.WriteFile("data.go", s, 0644); err != nil {
		log.Fatalln(err)
	}
}

const preamble = `// generated by go generate; DO NOT EDIT

// go:generate go run gen.go

package font

import (
	"image"
	"image/color"
)

`
